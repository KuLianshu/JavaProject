Thread基础知识
--------------------
#### 一、定义
1、程序：为了让计算机执行某些操作或者解决某些问题而执行的一系列有序的指令集合。</br>
2、进程：正在运行的程序，有自己独立的进程空间(数据在程序上的运行过程)。</br>
3、线程：在进程内的执行路径(线程)。</br>
4、在程序开始运行时，JVM会自动帮助我们创建一个线程，用来执行我们编写的代码,这个线程叫做主线程。</br>
5、线程是程序中代码的执行者。</br>

#### 二、创建线程
#### 既然开启子线程有两种方式：继承Thread类和实现Runnable接口，那么这两种方式有什么区别呢？
1、相同点：都能开启子线程</br>
2、不同点：</br>
  （1）如果采用继承Thread类开启子线程，那么由于java对类的单根继承，那么这个类就不能在继承其它类了;如果采用实现Runnable接口的方式开启子线程，那么这个类还可以继承其它类。</br>
（2）如果想让多线程访问共享资源，这时如果采用继承Thread类来完成，则会造成多线程无法访问共享资源，因为实例化多个线程时共享资源也被复制了多份，造成不再是共享资源，为了解决这个问题，需要将共享资源静态化，这样一来，虽然能够让多线程访问共享资源了，但共享资源的生命周期被延长了。
 如果采用实现Runnable接口的方式来完成资源共享最好的方式，因为我们只要实例化一个实现了Runnable接口的对象即可，
 多线程实例化时将同一个实现了Runnable接口的对象传递给多个线程即可。</br>
综上所述：如果多线程访问共享资源，建议使用实现Runnable接口的方式来完成，因为这是最好的方式。</br>

#### 开启子线程的时候必须调用线程对象的start()方法，不能调用线程对象的run()方法，因为如果调用线程对象的run()方法就成了普通的方法调用，不会产生子线程进行运行.为什么呢？
因为开启子线程需要调用操作系统底层的功能，这个代码都被封装到了线程对象的start()方法中，开启子线程需要首先调用操作系统底层的功能
开启子线程，同时将自己想要在开启子线程后执行的代码存放到线程的run()方法中，如果简单的调用线程对象的run()方法，则只是执行了开启
子线程后需要运行的代码，但由于之前调用操作系统底层的代码开启子线程的功能并没有调用，因此子线程开启失败。</br>

#### 多线程的运行具有不确定性:多次运行相同的代码可能得到的执行结果不一样.这是由CPU的切换造成的。

#### 同一个线程不能同时启动多次，否则报异常：Exception in thread "main" java.lang.IllegalThreadStateException






``````
//得到当前正在运行的线程
		Thread currentThread= Thread.currentThread();
``````
