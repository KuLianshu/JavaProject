Thread基础知识
--------------------

### 一、定义
1、程序：为了让计算机执行某些操作或者解决某些问题而执行的一系列有序的指令集合。</br>
2、进程：正在运行的程序，有自己独立的进程空间(数据在程序上的运行过程)。</br>
3、线程：在进程内的执行路径(线程)。</br>
4、在程序开始运行时，JVM会自动帮助我们创建一个线程，用来执行我们编写的代码,这个线程叫做主线程。</br>
5、线程是程序中代码的执行者。</br>

### 二、创建线程

#### 既然开启子线程有两种方式：继承Thread类和实现Runnable接口，那么这两种方式有什么区别呢？
1、相同点：都能开启子线程</br>
2、不同点：</br>
（1）如果采用继承Thread类开启子线程，那么由于java对类的单根继承，那么这个类就不能在继承其它类了;如果采用实现Runnable接口的方式开启子线程，那么这个类还可以继承其它类。</br>
（2）如果想让多线程访问共享资源，这时如果采用继承Thread类来完成，则会造成多线程无法访问共享资源，因为实例化多个线程时共享资源也被复制了多份，造成不再是共享资源，为了解决这个问题，需要将共享资源静态化，这样一来，虽然能够让多线程访问共享资源了，但共享资源的生命周期被延长了。
 如果采用实现Runnable接口的方式来完成资源共享最好的方式，因为我们只要实例化一个实现了Runnable接口的对象即可，
 多线程实例化时将同一个实现了Runnable接口的对象传递给多个线程即可。</br>
综上所述：如果多线程访问共享资源，建议使用实现Runnable接口的方式来完成，因为这是最好的方式。</br>

#### 开启子线程的时候必须调用线程对象的start()方法，不能调用线程对象的run()方法，因为如果调用线程对象的run()方法就成了普通的方法调用，不会产生子线程进行运行.为什么呢？
因为开启子线程需要调用操作系统底层的功能，这个代码都被封装到了线程对象的start()方法中，开启子线程需要首先调用操作系统底层的功能
开启子线程，同时将自己想要在开启子线程后执行的代码存放到线程的run()方法中，如果简单的调用线程对象的run()方法，则只是执行了开启
子线程后需要运行的代码，但由于之前调用操作系统底层的代码开启子线程的功能并没有调用，因此子线程开启失败。</br>

#### 多线程的运行具有不确定性:多次运行相同的代码可能得到的执行结果不一样.这是由CPU的切换造成的。

#### 同一个线程不能同时启动多次，否则报异常：Exception in thread "main" java.lang.IllegalThreadStateException


### 三、线程的优先级

#### 调整线程的优先级
1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有程序。优先级高的线程
会获得较多的运行机会。</br>
2、Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
MAX_PRIORITY：线程可以具有最高的优先级，取值为10。</br>
MIN_PRIORITY：线程可以具有的最低优先级，取值为0。</br>
NORM_PRIORITY：分配给线程的默认优先级，取值为5。</br>
3、Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
4、注意：优先级高的线程不一定会优先运行，优先级高的线程只是在同等条件下被CPU选中的概率比较大而已。

#### 调整线程的优先级示例
`````
	//设置线程t1的优先级为最高优先级10
	t1.setPriority(Thread.MAX_PRIORITY);
	/获取指定线程的优先级
	int priority=t1.getPriority();
	
`````

### 四、线程的基本用法
1、后台线程是为前台线程服务的，一旦所有的前台线程都已经死亡，则后台线程也就自动死亡了。</br>
2、在一个进程中，如果没有任何前台线程在运行，则这个进程就结束，当然在这个进程中的后台线程也会随之死亡。</br>

`````
//t1.isAlive():判断线程是否处于活动状态
System.out.println("t1.isAlive()1:"+t1.isAlive());
//返回线程的状态
State state=t1.getState();
//得到当前正在运行的线程
Thread currentThread= Thread.currentThread();
//将t1线程置为后台线程(守护线程，用户线程，精灵线程),这个操作必须在线程启动之前调用，否则报非法线程状态异常
t1.setDaemon(true);
t1.start();
`````

### 五、线程控制

1、start()：新建的线程进入Runnable状态。</br>
2、run()：线程进入Running状态。</br>
3、wait()：导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()唤醒。</br>
4、</br>
（1）notify()：唤醒在此对象监视器上等待的单个线程（如果多有线程都在此对象上等待，则会选择唤醒其中一个线程）。</br>
（2）notifyAll()：唤醒在此对象监视器上等待的所有线程。</br>
注意：wait()、notify()、notifyAll()只能在被同步化（synchronize）的方法或代码块中调用。

5、yield()：暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</br>
`````
Thread t1=new Thread(new Runnable() {

			@Override
			public void run() {
				for(int i=0;i<10;i++) {
					System.out.println(Thread.currentThread().getName()+"正在输出i="+i);
					//当前线程主动让出CPU使用权，给和它具有相同优先级或者比它优先级更高的线程运行
					Thread.yield();
				}
				
			}
			
		});
`````
6、getPriority()/setPriority()：获得/设置线程优先级。</br>
7、sleep()：线程睡眠。</br>
8、join()：在当前线程中调用另一个线程的join()方法，则当前线程转入WAITING状态，直到另一个线程运行结束，当前线程再由
阻塞转为就绪状态。</br>
`````
Thread t1=new Thread(new Runnable() {

			@Override
			public void run() {
				for(int i=0;i<300;i++) {
					System.out.println("线程"+Thread.currentThread().getName()+"正在输出"+i);
					
				}
				
			}
			
		});
		t1.setName("1");
		t1.start();
		
		for(int i=0;i<10;i++) {
			System.out.println("线程"+Thread.currentThread().getName()+"正在输出"+i);
			if(i==5) {
				try {
					/*
					 *当前线程main线程如果调用了线程对象t1的join()方法，则当前线程main会转入waiting状态，指定t1线程运行完毕后，
					 * 当前线程才会由wating状态自动转化为Runnable状态. 
					 */
					t1.join();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
`````

### 六、线程的停止

1、如果线程的run()方法中执行的是一个重复循环，可以提供一个标记来控制循环是否执行（看项目中的实例ThreadStopDemo01）。</br>
2、如果线程因为执行sleep()或是wait()而进入了阻塞状态，此时想要停止它，可使用interrrupt()，程序会抛出InterruptException异常。</br>
3、如果程序因为输入输出的等待而阻塞，基本上必须等待输入输出的动作完成才能离开阻塞状态。无法用I=interrupt()方法来使得线程离开run()方法，
要想离开，只能通过引发一个异常。</br>

### 七、线程的状态转换

#### 任何线程都具有五种状态：创建、就绪、运行、阻塞、终止。

1、创建（New）:新创建了一个线程。</br>
2、就绪（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法，使得该线程位于可运行线程池中，等待
获得CPU的使用权。获得了CPU，执行程序代码时也就属于就绪状态。</br>
3、运行（Running）：执行run()。</br>
4、阻塞（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。</br>
阻塞状态分三种：</br>
（1）同步阻塞：若该同步锁被别的线程占用，则JVM会把该线程放入锁池中；运行的线程在获取对象的同步锁时。</br>
（2）等待阻塞；运行的线程执行wait()方法，JVM会把该线程放入等待池中。</br>
（3）其他阻塞：运行的线程执行sleep()或join()方法;或者发出了I/O请求时，JVM会把该线程置为阻塞状态，
当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程就会重新转入就绪状态。</br>
5、终止（Dead）:线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</br>










