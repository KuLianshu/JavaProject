Thread基础知识
--------------------

### 一、定义
1、程序：为了让计算机执行某些操作或者解决某些问题而执行的一系列有序的指令集合。</br>
2、进程：正在运行的程序，有自己独立的进程空间(数据在程序上的运行过程)。</br>
3、线程：在进程内的执行路径(线程)。</br>
4、在程序开始运行时，JVM会自动帮助我们创建一个线程，用来执行我们编写的代码,这个线程叫做主线程。</br>
5、线程是程序中代码的执行者。</br>

### 二、创建线程

#### 既然开启子线程有两种方式：继承Thread类和实现Runnable接口，那么这两种方式有什么区别呢？
1、相同点：都能开启子线程</br>
2、不同点：</br>
  （1）如果采用继承Thread类开启子线程，那么由于java对类的单根继承，那么这个类就不能在继承其它类了;如果采用实现Runnable接口的方式开启子线程，那么这个类还可以继承其它类。</br>
（2）如果想让多线程访问共享资源，这时如果采用继承Thread类来完成，则会造成多线程无法访问共享资源，因为实例化多个线程时共享资源也被复制了多份，造成不再是共享资源，为了解决这个问题，需要将共享资源静态化，这样一来，虽然能够让多线程访问共享资源了，但共享资源的生命周期被延长了。
 如果采用实现Runnable接口的方式来完成资源共享最好的方式，因为我们只要实例化一个实现了Runnable接口的对象即可，
 多线程实例化时将同一个实现了Runnable接口的对象传递给多个线程即可。</br>
综上所述：如果多线程访问共享资源，建议使用实现Runnable接口的方式来完成，因为这是最好的方式。</br>

#### 开启子线程的时候必须调用线程对象的start()方法，不能调用线程对象的run()方法，因为如果调用线程对象的run()方法就成了普通的方法调用，不会产生子线程进行运行.为什么呢？
因为开启子线程需要调用操作系统底层的功能，这个代码都被封装到了线程对象的start()方法中，开启子线程需要首先调用操作系统底层的功能
开启子线程，同时将自己想要在开启子线程后执行的代码存放到线程的run()方法中，如果简单的调用线程对象的run()方法，则只是执行了开启
子线程后需要运行的代码，但由于之前调用操作系统底层的代码开启子线程的功能并没有调用，因此子线程开启失败。</br>

#### 多线程的运行具有不确定性:多次运行相同的代码可能得到的执行结果不一样.这是由CPU的切换造成的。

#### 同一个线程不能同时启动多次，否则报异常：Exception in thread "main" java.lang.IllegalThreadStateException


### 三、线程的优先级

#### 调整线程的优先级
1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有程序。优先级高的线程
会获得较多的运行机会。</br>
2、Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
MAX_PRIORITY：线程可以具有最高的优先级，取值为10。</br>
MIN_PRIORITY：线程可以具有的最低优先级，取值为0。</br>
NORM_PRIORITY：分配给线程的默认优先级，取值为5。</br>
3、Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
4、注意：优先级高的线程不一定会优先运行，优先级高的线程只是在同等条件下被CPU选中的概率比较大而已。

#### 调整线程的优先级示例
`````
	//设置线程t1的优先级为最高优先级10
	t1.setPriority(Thread.MAX_PRIORITY);
	/获取指定线程的优先级
	int priority=t1.getPriority();
	
`````

### 四、线程的基本用法
1、后台线程是为前台线程服务的，一旦所有的前台线程都已经死亡，则后台线程也就自动死亡了。</br>
2、在一个进程中，如果没有任何前台线程在运行，则这个进程就结束，当然在这个进程中的后台线程也会随之死亡。</br>

`````
//t1.isAlive():判断线程是否处于活动状态
System.out.println("t1.isAlive()1:"+t1.isAlive());
//返回线程的状态
State state=t1.getState();
//得到当前正在运行的线程
Thread currentThread= Thread.currentThread();
//将t1线程置为后台线程(守护线程，用户线程，精灵线程),这个操作必须在线程启动之前调用，否则报非法线程状态异常
t1.setDaemon(true);
t1.start();
`````

### 五、线程控制

	

